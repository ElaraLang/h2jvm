-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | See <a>https://hackage.haskell.org/package/h2jvm/docs/H2jvm.html</a>
@package h2jvm
@version 0.6.0.1

module Data.Binary.Write

-- | Like <a>Binary</a> but only supporting writing
class WriteBinary a
writeBinary :: WriteBinary a => a -> Put
writeList :: (WriteBinary a, Integral i, Foldable t) => (i -> Put) -> t a -> Put
instance Data.Binary.Class.Binary a => Data.Binary.Write.WriteBinary a


-- | An indexed map is an efficient map with integer keys, that can
--   efficiently retrieve the key from a value. This is used to efficiently
--   build up a constant pool without duplicating entries. Because of the
--   specialised nature, its indexes start at 1, not 0. I would apologise
--   but I'm not sorry.
module Data.IndexedMap
data IndexedMap a
IndexedMap :: !IntMap a -> !Map a Int -> IndexedMap a

-- | An empty indexed map &gt;&gt;&gt; lookup @String 1 empty Nothing
empty :: IndexedMap a

-- | Create an indexed map with a single element &gt;&gt;&gt; lookup
--   <tt>String 1 (singleton "hello") Just "hello" &gt;&gt;&gt; lookup
--   </tt>String 2 (singleton "hello") Nothing
singleton :: Ord a => a -> IndexedMap a
lookup :: Int -> IndexedMap a -> Maybe a

-- | Lookup a value in the map &gt;&gt;&gt; lookupIndex <tt>String "hello"
--   (singleton "hello") Just 1 &gt;&gt;&gt; lookupIndex </tt>String
--   "hello" (singleton "world") Nothing &gt;&gt;&gt; lookupIndex @String
--   "hello" (singleton "world" &lt;&gt; singleton "hello") Just 2
lookupIndex :: Ord a => a -> IndexedMap a -> Maybe Int

-- | Find the index of the first element that satisfies the predicate, if
--   any &gt;&gt;&gt; lookupIndexWhere (== "hello") (singleton "hello")
--   Just 1
--   
--   <pre>
--   &gt;&gt;&gt; lookupIndexWhere (== "hello") (singleton "world")
--   Nothing
--   </pre>
lookupIndexWhere :: (a -> Bool) -> IndexedMap a -> Maybe Int

-- | Insert a value into the map without checking if it already exists
insert :: Ord a => a -> IndexedMap a -> (Int, IndexedMap a)

-- | Lookup a value in the map, or insert it if it doesn't exist
lookupOrInsert :: Ord a => a -> IndexedMap a -> (Int, IndexedMap a)
lookupOrInsertM :: forall a (r :: [Effect]). (State (IndexedMap a) :> r, Ord a) => a -> Eff r Int
lookupOrInsertMOver :: forall a (r :: [Effect]) b. (State a :> r, Ord b) => Lens' a (IndexedMap b) -> b -> Eff r Int
isEmpty :: IndexedMap a -> Bool

-- | O(n) conversion to a vector This relies on the fact that IndexedMap is
--   strictly increasing in the key
--   
--   <pre>
--   &gt;&gt;&gt; toVector (singleton @Int 1)
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toVector (singleton @Int 1 &lt;&gt; singleton 2)
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toVector (singleton @Int 1 &lt;&gt; singleton 2 &lt;&gt; singleton 1)
--   [1,2]
--   </pre>
toVector :: IndexedMap a -> Vector a
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.IndexedMap.IndexedMap a)
instance GHC.Internal.Data.Foldable.Foldable Data.IndexedMap.IndexedMap
instance GHC.Classes.Ord a => GHC.Internal.IsList.IsList (Data.IndexedMap.IndexedMap a)
instance GHC.Classes.Ord a => GHC.Internal.Base.Monoid (Data.IndexedMap.IndexedMap a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.IndexedMap.IndexedMap a)
instance GHC.Classes.Ord a => GHC.Internal.Base.Semigroup (Data.IndexedMap.IndexedMap a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Data.IndexedMap.IndexedMap a)

module JVM.Data.Pretty
showPretty :: (IsString s, Pretty a) => a -> s
tracePrettyId :: Pretty a => a -> a

-- | Overloaded conversion to <a>Doc</a>.
--   
--   Laws:
--   
--   <ol>
--   <li>output should be pretty. :-)</li>
--   </ol>
class Pretty a

-- | <pre>
--   &gt;&gt;&gt; pretty 1 &lt;+&gt; pretty "hello" &lt;+&gt; pretty 1.234
--   1 hello 1.234
--   </pre>
pretty :: Pretty a => a -> Doc ann
($dmpretty) :: (Pretty a, Show a) => a -> Doc ann

-- | <tt><a>prettyList</a></tt> is only used to define the <tt>instance
--   <a>Pretty</a> a =&gt; <a>Pretty</a> [a]</tt>. In normal circumstances
--   only the <tt><a>pretty</a></tt> function is used.
--   
--   <pre>
--   &gt;&gt;&gt; prettyList [1, 23, 456]
--   [1, 23, 456]
--   </pre>
prettyList :: Pretty a => [a] -> Doc ann

-- | <tt>(x <a>&lt;+&gt;</a> y)</tt> concatenates document <tt>x</tt> and
--   <tt>y</tt> with a <tt><tt>space</tt></tt> in between.
--   
--   <pre>
--   &gt;&gt;&gt; "hello" &lt;+&gt; "world"
--   hello world
--   </pre>
--   
--   <pre>
--   x <a>&lt;+&gt;</a> y = x <a>&lt;&gt;</a> <tt>space</tt> <a>&lt;&gt;</a> y
--   </pre>
(<+>) :: Doc ann -> Doc ann -> Doc ann
infixr 6 <+>

-- | <tt>(<a>hsep</a> xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt><a>&lt;+&gt;</a></tt>, i.e. it puts a space
--   between all entries.
--   
--   <pre>
--   &gt;&gt;&gt; let docs = Util.words "lorem ipsum dolor sit amet"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hsep docs
--   lorem ipsum dolor sit amet
--   </pre>
--   
--   <tt><a>hsep</a></tt> does not introduce line breaks on its own, even
--   when the page is too narrow:
--   
--   <pre>
--   &gt;&gt;&gt; putDocW 5 (hsep docs)
--   lorem ipsum dolor sit amet
--   </pre>
--   
--   For automatic line breaks, consider using <a>fillSep</a> instead.
hsep :: [Doc ann] -> Doc ann
instance Prettyprinter.Internal.Pretty (Prettyprinter.Internal.Doc a)


-- | Information about JVM Versions
module JVM.Data.JVMVersion

-- | A JVM Version Number
newtype JVMVersion
JVMVersion :: Word16 -> JVMVersion
newtype MajorVersion
MajorVersion :: Word16 -> MajorVersion
newtype MinorVersion
MinorVersion :: Word16 -> MinorVersion
unwrapMajor :: MajorVersion -> Word16
unwrapMinor :: MinorVersion -> Word16
getMajor :: JVMVersion -> MajorVersion
getMinor :: JVMVersion -> MinorVersion
java6 :: JVMVersion
java7 :: JVMVersion
java8 :: JVMVersion
java9 :: JVMVersion
java10 :: JVMVersion
java11 :: JVMVersion
java12 :: JVMVersion
java13 :: JVMVersion
java14 :: JVMVersion
java15 :: JVMVersion
java16 :: JVMVersion
java17 :: JVMVersion
java18 :: JVMVersion
java19 :: JVMVersion
java20 :: JVMVersion
java21 :: JVMVersion
isLTS :: JVMVersion -> Bool

-- | Returns true if the JVM version is EOL at the time of writing (April
--   2023) This is for OpenJDK, other vendors may have different EOL dates
isEOL :: JVMVersion -> Bool
instance GHC.Classes.Eq JVM.Data.JVMVersion.JVMVersion
instance GHC.Classes.Eq JVM.Data.JVMVersion.MajorVersion
instance GHC.Classes.Eq JVM.Data.JVMVersion.MinorVersion
instance GHC.Internal.Num.Num JVM.Data.JVMVersion.MajorVersion
instance GHC.Internal.Num.Num JVM.Data.JVMVersion.MinorVersion
instance GHC.Classes.Ord JVM.Data.JVMVersion.JVMVersion
instance GHC.Classes.Ord JVM.Data.JVMVersion.MajorVersion
instance GHC.Classes.Ord JVM.Data.JVMVersion.MinorVersion
instance Prettyprinter.Internal.Pretty JVM.Data.JVMVersion.JVMVersion
instance GHC.Internal.Show.Show JVM.Data.JVMVersion.JVMVersion
instance GHC.Internal.Show.Show JVM.Data.JVMVersion.MajorVersion
instance GHC.Internal.Show.Show JVM.Data.JVMVersion.MinorVersion

module JVM.Data.Abstract.Name

-- | A JVM package name This is defined as a potentially empty list of
--   identifiers, which would be separated by dots in the source code
newtype PackageName
PackageName :: [Text] -> PackageName

-- | Parse a <a>PackageName</a> from a <a>Text</a>
--   
--   <pre>
--   &gt;&gt;&gt; parsePackageName "java.lang"
--   PackageName ["java","lang"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parsePackageName ""
--   PackageName []
--   </pre>
parsePackageName :: Text -> PackageName

-- | A JVM class name
newtype ClassName
ClassName :: Text -> ClassName

-- | Parse a <a>ClassName</a> from a <a>Text</a>
parseClassName :: Text -> ClassName
data QualifiedClassName
QualifiedClassName :: PackageName -> ClassName -> QualifiedClassName

-- | Parse a <a>QualifiedClassName</a> from a <a>Text</a>
--   
--   <pre>
--   &gt;&gt;&gt; parseQualifiedClassName "java.lang.Object"
--   QualifiedClassName (PackageName ["java","lang"]) (ClassName "Object")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseQualifiedClassName "Object"
--   QualifiedClassName (PackageName []) (ClassName "Object")
--   </pre>
--   
--   This function is lenient and will accept invalid class names:
--   &gt;&gt;&gt; parseQualifiedClassName "123invalid" QualifiedClassName
--   (PackageName []) (ClassName "123invalid")
parseQualifiedClassName :: Text -> QualifiedClassName

-- | Convert a <a>QualifiedClassName</a> to a <a>Text</a> that can be used
--   as an internal JVM name
--   
--   <pre>
--   &gt;&gt;&gt; toInternalName (QualifiedClassName (PackageName ["java","lang"]) (ClassName "Object"))
--   "java/lang/Object"
--   </pre>
toInternalName :: QualifiedClassName -> Text

-- | Convert a <a>QualifiedClassName</a> to a <a>FilePath</a> that one
--   would expect the class file to be in &gt;&gt;&gt; suitableFilePath
--   "java.lang.Object" "java<i>lang</i>Object.class"
--   
--   <pre>
--   &gt;&gt;&gt; suitableFilePath "Object"
--   "Object.class"
--   </pre>
suitableFilePath :: QualifiedClassName -> FilePath
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.Name.ClassName
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.Name.PackageName
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.Name.QualifiedClassName
instance GHC.Classes.Eq JVM.Data.Abstract.Name.ClassName
instance GHC.Classes.Eq JVM.Data.Abstract.Name.PackageName
instance GHC.Classes.Eq JVM.Data.Abstract.Name.QualifiedClassName
instance GHC.Internal.Data.String.IsString JVM.Data.Abstract.Name.QualifiedClassName
instance GHC.Classes.Ord JVM.Data.Abstract.Name.ClassName
instance GHC.Classes.Ord JVM.Data.Abstract.Name.PackageName
instance GHC.Classes.Ord JVM.Data.Abstract.Name.QualifiedClassName
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.Name.QualifiedClassName
instance GHC.Internal.Show.Show JVM.Data.Abstract.Name.ClassName
instance GHC.Internal.Show.Show JVM.Data.Abstract.Name.PackageName
instance GHC.Internal.Show.Show JVM.Data.Abstract.Name.QualifiedClassName

module JVM.Data.Abstract.Type
data PrimitiveType
Byte :: PrimitiveType
Char :: PrimitiveType
Double :: PrimitiveType
Float :: PrimitiveType
Int :: PrimitiveType
Long :: PrimitiveType
Short :: PrimitiveType
Boolean :: PrimitiveType
data FieldType
PrimitiveFieldType :: PrimitiveType -> FieldType
ObjectFieldType :: QualifiedClassName -> FieldType
ArrayFieldType :: FieldType -> FieldType
fieldTypeToClassInfoType :: FieldType -> ClassInfoType
data ClassInfoType
ClassInfoType :: QualifiedClassName -> ClassInfoType
PrimitiveClassInfoType :: PrimitiveType -> ClassInfoType
ArrayClassInfoType :: ClassInfoType -> ClassInfoType
classInfoTypeToFieldType :: ClassInfoType -> FieldType
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.Type.ClassInfoType
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.Type.FieldType
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.Type.PrimitiveType
instance GHC.Classes.Eq JVM.Data.Abstract.Type.ClassInfoType
instance GHC.Classes.Eq JVM.Data.Abstract.Type.FieldType
instance GHC.Classes.Eq JVM.Data.Abstract.Type.PrimitiveType
instance GHC.Classes.Ord JVM.Data.Abstract.Type.ClassInfoType
instance GHC.Classes.Ord JVM.Data.Abstract.Type.FieldType
instance GHC.Classes.Ord JVM.Data.Abstract.Type.PrimitiveType
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.Type.ClassInfoType
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.Type.FieldType
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.Type.PrimitiveType
instance GHC.Internal.Show.Show JVM.Data.Abstract.Type.ClassInfoType
instance GHC.Internal.Show.Show JVM.Data.Abstract.Type.FieldType
instance GHC.Internal.Show.Show JVM.Data.Abstract.Type.PrimitiveType

module JVM.Data.Convert.Type
baseTypeDescriptor :: PrimitiveType -> Text
fieldTypeDescriptor :: FieldType -> Text
classInfoTypeDescriptor :: ClassInfoType -> Text

module JVM.Data.Abstract.Descriptor
data MethodDescriptor
MethodDescriptor :: [FieldType] -> ReturnDescriptor -> MethodDescriptor
[params] :: MethodDescriptor -> [FieldType]
[returnDesc] :: MethodDescriptor -> ReturnDescriptor
methodParam :: MethodDescriptor -> Int -> Maybe FieldType
data ReturnDescriptor
VoidReturn :: ReturnDescriptor
TypeReturn :: FieldType -> ReturnDescriptor
returnDescriptorType :: ReturnDescriptor -> Maybe FieldType
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.Descriptor.MethodDescriptor
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.Descriptor.ReturnDescriptor
instance GHC.Classes.Eq JVM.Data.Abstract.Descriptor.MethodDescriptor
instance GHC.Classes.Eq JVM.Data.Abstract.Descriptor.ReturnDescriptor
instance GHC.Classes.Ord JVM.Data.Abstract.Descriptor.MethodDescriptor
instance GHC.Classes.Ord JVM.Data.Abstract.Descriptor.ReturnDescriptor
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.Descriptor.MethodDescriptor
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.Descriptor.ReturnDescriptor
instance GHC.Internal.Show.Show JVM.Data.Abstract.Descriptor.MethodDescriptor
instance GHC.Internal.Show.Show JVM.Data.Abstract.Descriptor.ReturnDescriptor

module JVM.Data.Convert.Descriptor
convertMethodDescriptor :: MethodDescriptor -> Text


-- | Provides a monadic interface to the constant pool. This aims to
--   eliminate the need to manually specify the index of the constant
module JVM.Data.Abstract.ConstantPool

-- | High-level, type-safe representation of a constant pool entry This
--   tries to hide indexes as much as possible, instead just allowing the
--   values to be provided directly. These are transformed into the correct
--   indexes when the constant pool is built, which uses a state monad to
--   avoid repeating entries.
data ConstantPoolEntry

-- | A class reference
CPClassEntry :: ClassInfoType -> ConstantPoolEntry
CPFieldRefEntry :: FieldRef -> ConstantPoolEntry
CPMethodRefEntry :: MethodRef -> ConstantPoolEntry
CPInterfaceMethodRefEntry :: MethodRef -> ConstantPoolEntry
CPStringEntry :: Text -> ConstantPoolEntry
CPIntegerEntry :: Int -> ConstantPoolEntry
CPFloatEntry :: Float -> ConstantPoolEntry
CPLongEntry :: Int64 -> ConstantPoolEntry
CPDoubleEntry :: Double -> ConstantPoolEntry
CPNameAndTypeEntry :: Text -> Text -> ConstantPoolEntry
CPUTF8Entry :: Text -> ConstantPoolEntry
CPMethodHandleEntry :: MethodHandleEntry -> ConstantPoolEntry
CPMethodTypeEntry :: MethodDescriptor -> ConstantPoolEntry

-- | CONSTANT_InvokeDynamic_info
CPInvokeDynamicEntry :: BootstrapMethod -> Text -> MethodDescriptor -> ConstantPoolEntry
data MethodHandleEntry
MHGetField :: FieldRef -> MethodHandleEntry
MHGetStatic :: FieldRef -> MethodHandleEntry
MHPutField :: FieldRef -> MethodHandleEntry
MHPutStatic :: FieldRef -> MethodHandleEntry
MHInvokeVirtual :: MethodRef -> MethodHandleEntry
MHNewInvokeSpecial :: MethodRef -> MethodHandleEntry
MHInvokeStatic :: MethodRef -> MethodHandleEntry
MHInvokeSpecial :: MethodRef -> MethodHandleEntry
MHInvokeInterface :: MethodRef -> MethodHandleEntry
data FieldRef
FieldRef :: ClassInfoType -> Text -> FieldType -> FieldRef
data MethodRef
MethodRef :: ClassInfoType -> Text -> MethodDescriptor -> MethodRef
data BootstrapMethod
BootstrapMethod :: MethodHandleEntry -> [BootstrapArgument] -> BootstrapMethod
data BootstrapArgument
BMClassArg :: ClassInfoType -> BootstrapArgument
BMStringArg :: Text -> BootstrapArgument
BMIntArg :: Int -> BootstrapArgument
BMMethodArg :: MethodDescriptor -> BootstrapArgument
BMMethodHandleArg :: MethodHandleEntry -> BootstrapArgument
bmArgToCPEntry :: BootstrapArgument -> ConstantPoolEntry
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.ConstantPool.BootstrapArgument
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.ConstantPool.BootstrapMethod
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.ConstantPool.FieldRef
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.ConstantPool.MethodHandleEntry
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.ConstantPool.MethodRef
instance GHC.Classes.Eq JVM.Data.Abstract.ConstantPool.BootstrapArgument
instance GHC.Classes.Eq JVM.Data.Abstract.ConstantPool.BootstrapMethod
instance GHC.Classes.Eq JVM.Data.Abstract.ConstantPool.ConstantPoolEntry
instance GHC.Classes.Eq JVM.Data.Abstract.ConstantPool.FieldRef
instance GHC.Classes.Eq JVM.Data.Abstract.ConstantPool.MethodHandleEntry
instance GHC.Classes.Eq JVM.Data.Abstract.ConstantPool.MethodRef
instance GHC.Classes.Ord JVM.Data.Abstract.ConstantPool.BootstrapArgument
instance GHC.Classes.Ord JVM.Data.Abstract.ConstantPool.BootstrapMethod
instance GHC.Classes.Ord JVM.Data.Abstract.ConstantPool.ConstantPoolEntry
instance GHC.Classes.Ord JVM.Data.Abstract.ConstantPool.FieldRef
instance GHC.Classes.Ord JVM.Data.Abstract.ConstantPool.MethodHandleEntry
instance GHC.Classes.Ord JVM.Data.Abstract.ConstantPool.MethodRef
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ConstantPool.BootstrapArgument
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ConstantPool.BootstrapMethod
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ConstantPool.FieldRef
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ConstantPool.MethodHandleEntry
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ConstantPool.MethodRef
instance GHC.Internal.Show.Show JVM.Data.Abstract.ConstantPool.BootstrapArgument
instance GHC.Internal.Show.Show JVM.Data.Abstract.ConstantPool.BootstrapMethod
instance GHC.Internal.Show.Show JVM.Data.Abstract.ConstantPool.ConstantPoolEntry
instance GHC.Internal.Show.Show JVM.Data.Abstract.ConstantPool.FieldRef
instance GHC.Internal.Show.Show JVM.Data.Abstract.ConstantPool.MethodHandleEntry
instance GHC.Internal.Show.Show JVM.Data.Abstract.ConstantPool.MethodRef

module JVM.Data.Abstract.ClassFile.AccessFlags

-- | Access flags for a class
data ClassAccessFlag
Public :: ClassAccessFlag
Final :: ClassAccessFlag
Super :: ClassAccessFlag
Interface :: ClassAccessFlag
Abstract :: ClassAccessFlag
Synthetic :: ClassAccessFlag
Annotation :: ClassAccessFlag
Enum :: ClassAccessFlag
data FieldAccessFlag
FPublic :: FieldAccessFlag
FPrivate :: FieldAccessFlag
FProtected :: FieldAccessFlag
FStatic :: FieldAccessFlag
FFinal :: FieldAccessFlag
FVolatile :: FieldAccessFlag
FTransient :: FieldAccessFlag
FSynthetic :: FieldAccessFlag
FEnum :: FieldAccessFlag
data MethodAccessFlag
MPublic :: MethodAccessFlag
MPrivate :: MethodAccessFlag
MProtected :: MethodAccessFlag
MStatic :: MethodAccessFlag
MFinal :: MethodAccessFlag
MSynchronized :: MethodAccessFlag
MBridge :: MethodAccessFlag
MVarargs :: MethodAccessFlag
MNative :: MethodAccessFlag
MAbstract :: MethodAccessFlag
MStrict :: MethodAccessFlag
MSynthetic :: MethodAccessFlag
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.ClassFile.AccessFlags.ClassAccessFlag
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.ClassFile.AccessFlags.FieldAccessFlag
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.ClassFile.AccessFlags.MethodAccessFlag
instance GHC.Classes.Eq JVM.Data.Abstract.ClassFile.AccessFlags.ClassAccessFlag
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ClassFile.AccessFlags.ClassAccessFlag
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ClassFile.AccessFlags.FieldAccessFlag
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ClassFile.AccessFlags.MethodAccessFlag
instance GHC.Internal.Show.Show JVM.Data.Abstract.ClassFile.AccessFlags.ClassAccessFlag
instance GHC.Internal.Show.Show JVM.Data.Abstract.ClassFile.AccessFlags.FieldAccessFlag
instance GHC.Internal.Show.Show JVM.Data.Abstract.ClassFile.AccessFlags.MethodAccessFlag


-- | Label type for instructions This data type allows referring to
--   specific instructions (for jumps) without having to manually calculate
--   their offsets. A label represents a <b>unique</b> instruction in a
--   Code attribute, and is marked by inserting a <a>Label</a> instruction
--   <b>directly above</b> the instruction it refers to. For example, the
--   following (contrived) code:
--   
--   <pre>
--   0: aload_0
--   1: ifeq          4
--   4: return
--   </pre>
--   
--   could be written as follows, using <a>CodeBuilder</a>:
--   
--   <pre>
--   emit ALoad0
--   label &lt;- newLabel
--   emit (IfEq label)
--   emit (Label label)
--   emit Return
--   </pre>
module JVM.Data.Abstract.Builder.Label
newtype Label
MkLabel :: Int -> Label
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.Builder.Label.Label
instance GHC.Classes.Eq JVM.Data.Abstract.Builder.Label.Label
instance GHC.Classes.Ord JVM.Data.Abstract.Builder.Label.Label
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.Builder.Label.Label
instance GHC.Internal.Show.Show JVM.Data.Abstract.Builder.Label.Label


-- | A Snoc List type that merges elements of the same constructor using
--   the Semigroup instance. For example, suppose we have some data type:
--   &gt; data Entry = IntEntry Int | StringEntry String deriving (Eq,
--   Data, Show) &gt; instance Semigroup Entry where &gt; IntEntry a
--   &lt;&gt; IntEntry b = IntEntry (a + b) &gt; StringEntry a &lt;&gt;
--   StringEntry b = StringEntry (a ++ b) &gt; _ &lt;&gt; b = b -- if the
--   constructors don't match, just take the right one
--   
--   Then we can do: &gt; snoc (TypeMergingList []) (IntEntry 1) =
--   TypeMergingList [IntEntry 1] &gt; snoc (TypeMergingList [IntEntry 1])
--   (IntEntry 2) = TypeMergingList [IntEntry 3] &gt; snoc (TypeMergingList
--   [IntEntry 1]) (StringEntry "hello") = TypeMergingList [IntEntry 1,
--   StringEntry "hello"] &gt; snoc (TypeMergingList [IntEntry 1,
--   StringEntry "hello"]) (StringEntry "world") = TypeMergingList
--   [IntEntry 1, StringEntry "helloworld"]
module Data.TypeMergingList
newtype TypeMergingList a
TypeMergingList :: [a] -> TypeMergingList a

-- | Class of partially mergeable types. Instances of this class may assume
--   that the constructors of the two arguments are the same (i.e.
--   <tt>toConstr x == toConstr y</tt>), and are permitted to be partial if
--   this is not the case.
class Data a => DataMergeable a
merge :: DataMergeable a => a -> a -> a
errorDifferentConstructors :: Data a => a -> a -> b
getByCtor :: forall (ctor :: Symbol) s a. (Generic s, AsConstructor ctor s s a a) => TypeMergingList s -> Maybe a
snoc :: DataMergeable a => TypeMergingList a -> a -> TypeMergingList a
append :: DataMergeable a => TypeMergingList a -> TypeMergingList a -> TypeMergingList a
fromList :: (DataMergeable a, Data a) => [a] -> TypeMergingList a
toList :: TypeMergingList a -> [a]
toVector :: TypeMergingList a -> Vector a
instance (GHC.Internal.Data.Data.Data a, GHC.Internal.Base.Semigroup a) => Data.TypeMergingList.DataMergeable a
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.TypeMergingList.TypeMergingList a)
instance GHC.Internal.Data.Foldable.Foldable Data.TypeMergingList.TypeMergingList
instance Data.TypeMergingList.DataMergeable a => GHC.Internal.IsList.IsList (Data.TypeMergingList.TypeMergingList a)
instance Data.TypeMergingList.DataMergeable a => GHC.Internal.Base.Monoid (Data.TypeMergingList.TypeMergingList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.TypeMergingList.TypeMergingList a)
instance Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Data.TypeMergingList.TypeMergingList a)
instance Data.TypeMergingList.DataMergeable a => GHC.Internal.Base.Semigroup (Data.TypeMergingList.TypeMergingList a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Data.TypeMergingList.TypeMergingList a)


-- | This module contains all the magic numbers used in the JVM class file
--   format.
module JVM.Data.Raw.MagicNumbers

-- | Magic number for all class files
classMagic :: Word32
accessFlag_PUBLIC :: Word16
accessFlag_PRIVATE :: Word16
accessFlag_PROTECTED :: Word16
accessFlag_STATIC :: Word16
accessFlag_FINAL :: Word16
accessFlag_VOLATILE :: Word16
accessFlag_TRANSIENT :: Word16
accessFlag_SUPER :: Word16
accessFlag_INTERFACE :: Word16
accessFlag_ABSTRACT :: Word16
accessFlag_SYNTHETIC :: Word16
accessFlag_ANNOTATION :: Word16
accessFlag_ENUM :: Word16
accessFlag_SYNCHRONIZED :: Word16
accessFlag_BRIDGE :: Word16
accessFlag_VARARGS :: Word16
accessFlag_NATIVE :: Word16
accessFlag_STRICT :: Word16
_REF_getField :: Word8
_REF_getStatic :: Word8
_REF_putField :: Word8
_REF_putStatic :: Word8
_REF_invokeVirtual :: Word8
_REF_invokeStatic :: Word8
_REF_invokeSpecial :: Word8
_REF_newInvokeSpecial :: Word8
_REF_invokeInterface :: Word8
constant_Class :: Word8
constant_Fieldref :: Word8
constant_Methodref :: Word8
constant_InterfaceMethodref :: Word8
constant_String :: Word8
constant_Integer :: Word8
constant_Float :: Word8
constant_Long :: Word8
constant_Double :: Word8
constant_NameAndType :: Word8
constant_Utf8 :: Word8
constant_MethodHandle :: Word8
constant_MethodType :: Word8
constant_InvokeDynamic :: Word8
verificationType_info_TopVariableInfo :: Word8
verificationType_info_IntegerVariableInfo :: Word8
verificationType_info_FloatVariableInfo :: Word8
verificationType_info_DoubleVariableInfo :: Word8
verificationType_info_LongVariableInfo :: Word8
verificationType_info_NullVariableInfo :: Word8
verificationType_info_UninitializedThisVariableInfo :: Word8
verificationType_info_ObjectVariableInfo :: Word8
verificationType_info_UninitializedVariableInfo :: Word8
instruction_aaLoad :: Word8
instruction_aaStore :: Word8
instruction_aConstNull :: Word8
instruction_aLoad :: Word8
instruction_aLoad0 :: Word8
instruction_aLoad1 :: Word8
instruction_aLoad2 :: Word8
instruction_aLoad3 :: Word8
instruction_aNewArray :: Word8
instruction_aReturn :: Word8
instruction_aStore :: Word8
instruction_aStore0 :: Word8
instruction_aStore1 :: Word8
instruction_aStore2 :: Word8
instruction_aStore3 :: Word8
instruction_arrayLength :: Word8
instruction_aThrow :: Word8
instruction_baLoad :: Word8
instruction_baStore :: Word8
instruction_biPush :: Word8
instruction_breakpoint :: Word8
instruction_caLoad :: Word8
instruction_caStore :: Word8
instruction_checkCast :: Word8
instruction_d2f :: Word8
instruction_d2i :: Word8
instruction_d2l :: Word8
instruction_dAdd :: Word8
instruction_daLoad :: Word8
instruction_daStore :: Word8
instruction_dCmpG :: Word8
instruction_dCmpL :: Word8
instruction_dConst0 :: Word8
instruction_dConst1 :: Word8
instruction_dDiv :: Word8
instruction_dLoad :: Word8
instruction_dLoad0 :: Word8
instruction_dLoad1 :: Word8
instruction_dLoad2 :: Word8
instruction_dLoad3 :: Word8
instruction_dMul :: Word8
instruction_dNeg :: Word8
instruction_dRem :: Word8
instruction_dReturn :: Word8
instruction_dStore :: Word8
instruction_dStore0 :: Word8
instruction_dStore1 :: Word8
instruction_dStore2 :: Word8
instruction_dStore3 :: Word8
instruction_dSub :: Word8
instruction_dup :: Word8
instruction_dup2 :: Word8
instruction_dup2X1 :: Word8
instruction_dup2X2 :: Word8
instruction_dupX1 :: Word8
instruction_dupX2 :: Word8
instruction_f2d :: Word8
instruction_f2i :: Word8
instruction_f2l :: Word8
instruction_fAdd :: Word8
instruction_faLoad :: Word8
instruction_faStore :: Word8
instruction_fCmpG :: Word8
instruction_fCmpL :: Word8
instruction_fConst0 :: Word8
instruction_fConst1 :: Word8
instruction_fConst2 :: Word8
instruction_fDiv :: Word8
instruction_fLoad :: Word8
instruction_fLoad0 :: Word8
instruction_fLoad1 :: Word8
instruction_fLoad2 :: Word8
instruction_fLoad3 :: Word8
instruction_fMul :: Word8
instruction_fNeg :: Word8
instruction_fRem :: Word8
instruction_fReturn :: Word8
instruction_fStore :: Word8
instruction_fStore0 :: Word8
instruction_fStore1 :: Word8
instruction_fStore2 :: Word8
instruction_fStore3 :: Word8
instruction_fSub :: Word8
instruction_getField :: Word8
instruction_getStatic :: Word8
instruction_goto :: Word8
instruction_gotoW :: Word8
instruction_i2b :: Word8
instruction_i2c :: Word8
instruction_i2d :: Word8
instruction_i2f :: Word8
instruction_i2l :: Word8
instruction_i2s :: Word8
instruction_iAdd :: Word8
instruction_iALoad :: Word8
instruction_iAStore :: Word8
instruction_iAnd :: Word8
instruction_iCmp :: Word8
instruction_iConstM1 :: Word8
instruction_iConst0 :: Word8
instruction_iConst1 :: Word8
instruction_iConst2 :: Word8
instruction_iConst3 :: Word8
instruction_iConst4 :: Word8
instruction_iConst5 :: Word8
instruction_iDiv :: Word8
instruction_iLoad :: Word8
instruction_iLoad0 :: Word8
instruction_iLoad1 :: Word8
instruction_iLoad2 :: Word8
instruction_iLoad3 :: Word8
instruction_iMul :: Word8
instruction_iNeg :: Word8
instruction_instanceOf :: Word8
instruction_invokeDynamic :: Word8
instruction_invokeInterface :: Word8
instruction_invokeSpecial :: Word8
instruction_invokeStatic :: Word8
instruction_invokeVirtual :: Word8
instruction_iOr :: Word8
instruction_iRem :: Word8
instruction_iReturn :: Word8
instruction_iShl :: Word8
instruction_iShr :: Word8
instruction_iStore :: Word8
instruction_iStore0 :: Word8
instruction_iStore1 :: Word8
instruction_iStore2 :: Word8
instruction_iStore3 :: Word8
instruction_iSub :: Word8
instruction_iUShr :: Word8
instruction_iXor :: Word8
instruction_ifAcmpeq :: Word8
instruction_ifAcmpne :: Word8
instruction_ifIcmpeq :: Word8
instruction_ifIcmpne :: Word8
instruction_ifIcmplt :: Word8
instruction_ifIcmpge :: Word8
instruction_ifIcmpgt :: Word8
instruction_ifIcmple :: Word8
instruction_ifEq :: Word8
instruction_ifNe :: Word8
instruction_ifLt :: Word8
instruction_ifGe :: Word8
instruction_ifGt :: Word8
instruction_ifLe :: Word8
instruction_ifNonNull :: Word8
instruction_ifNull :: Word8
instruction_iInc :: Word8
instruction_jsr :: Word8
instruction_jsrW :: Word8
instruction_l2d :: Word8
instruction_l2f :: Word8
instruction_l2i :: Word8
instruction_lAdd :: Word8
instruction_lALoad :: Word8
instruction_lAnd :: Word8
instruction_lAStore :: Word8
instruction_lCmp :: Word8
instruction_lConst0 :: Word8
instruction_lConst1 :: Word8
instruction_ldc :: Word8
instruction_ldcW :: Word8
instruction_ldc2W :: Word8
instruction_lDiv :: Word8
instruction_lLoad :: Word8
instruction_lLoad0 :: Word8
instruction_lLoad1 :: Word8
instruction_lLoad2 :: Word8
instruction_lLoad3 :: Word8
instruction_lMul :: Word8
instruction_lNeg :: Word8
instruction_lookupSwitch :: Word8
instruction_lOr :: Word8
instruction_lRem :: Word8
instruction_lReturn :: Word8
instruction_lShl :: Word8
instruction_lShr :: Word8
instruction_lStore :: Word8
instruction_lStore0 :: Word8
instruction_lStore1 :: Word8
instruction_lStore2 :: Word8
instruction_lStore3 :: Word8
instruction_lSub :: Word8
instruction_lUShr :: Word8
instruction_lXor :: Word8
instruction_monitorEnter :: Word8
instruction_monitorExit :: Word8
instruction_multiANewArray :: Word8
instruction_new :: Word8
instruction_newArray :: Word8
instruction_nop :: Word8
instruction_pop :: Word8
instruction_pop2 :: Word8
instruction_putField :: Word8
instruction_putStatic :: Word8
instruction_ret :: Word8
instruction_return :: Word8
instruction_sALoad :: Word8
instruction_sAStore :: Word8
instruction_sIPush :: Word8
instruction_swap :: Word8
instruction_tableSwitch :: Word8
instruction_wide :: Word8

module JVM.Data.Raw.AccessFlags

-- | Very thin wrapper around the access flags defined in the JVM spec.
--   These flags may be for a class, field, or method - for a safer
--   interface, see <a>AccessFlags</a>.
data AccessFlag
ACC_PUBLIC :: AccessFlag
ACC_PRIVATE :: AccessFlag
ACC_PROTECTED :: AccessFlag
ACC_STATIC :: AccessFlag
ACC_FINAL :: AccessFlag
ACC_VOLATILE :: AccessFlag
ACC_TRANSIENT :: AccessFlag
ACC_SUPER :: AccessFlag
ACC_INTERFACE :: AccessFlag
ACC_ABSTRACT :: AccessFlag
ACC_SYNTHETIC :: AccessFlag
ACC_ANNOTATION :: AccessFlag
ACC_ENUM :: AccessFlag
ACC_SYNCHRONIZED :: AccessFlag
ACC_BRIDGE :: AccessFlag
ACC_VARARGS :: AccessFlag
ACC_NATIVE :: AccessFlag
ACC_STRICT :: AccessFlag
accessFlagValue :: AccessFlag -> Word16
instance GHC.Internal.Show.Show JVM.Data.Raw.AccessFlags.AccessFlag
instance Data.Binary.Write.WriteBinary JVM.Data.Raw.AccessFlags.AccessFlag

module JVM.Data.Convert.AccessFlag
class ConvertAccessFlag a
convertAccessFlag :: ConvertAccessFlag a => a -> AccessFlag
accessFlagsToWord16 :: ConvertAccessFlag a => [a] -> Word16
instance JVM.Data.Convert.AccessFlag.ConvertAccessFlag JVM.Data.Abstract.ClassFile.AccessFlags.ClassAccessFlag
instance JVM.Data.Convert.AccessFlag.ConvertAccessFlag JVM.Data.Abstract.ClassFile.AccessFlags.FieldAccessFlag
instance JVM.Data.Convert.AccessFlag.ConvertAccessFlag JVM.Data.Abstract.ClassFile.AccessFlags.MethodAccessFlag


-- | Types and type synonyms for raw JVM data
module JVM.Data.Raw.Types
type U1 = Word8
type U2 = Word16
type U4 = Word32
type U8 = Word64
type JVMInt = U4
type JVMFloat = Float
type JVMLong = U8
type JVMDouble = Double
type JVMString = Text

-- | An offset for an instruction, used for jumps
type InstOffsetBytes = U2

-- | Converts an <a>InstOffsetBytes</a> to a pair of bytes, encoding it a
--   way that the JVM will correctly interpret it In other words, this
--   function does the opposite of <tt>(branchbyte1 &lt;&lt; 8) |
--   branchbyte2</tt> &gt;&gt;&gt; instOffsetBytesToU2 39 (0,39)
instOffsetBytesToU2 :: InstOffsetBytes -> (U1, U1)

-- | A constant pool index
type ConstantPoolIndex = U2

-- | An "array type code" for the <tt>newarray</tt> instruction
type ArrayType = U1

module JVM.Data.Raw.Instruction
data Instruction
AALoad :: Instruction
AAStore :: Instruction
AConstNull :: Instruction
ALoad :: U1 -> Instruction
ALoad0 :: Instruction
ALoad1 :: Instruction
ALoad2 :: Instruction
ALoad3 :: Instruction
ANewArray :: ConstantPoolIndex -> Instruction
AReturn :: Instruction
ArrayLength :: Instruction
AStore :: U1 -> Instruction
AStore0 :: Instruction
AStore1 :: Instruction
AStore2 :: Instruction
AStore3 :: Instruction
AThrow :: Instruction
BALoad :: Instruction
BAStore :: Instruction
BIPush :: Word8 -> Instruction
CALoad :: Instruction
CAStore :: Instruction
CheckCast :: ConstantPoolIndex -> Instruction
D2F :: Instruction
D2I :: Instruction
D2L :: Instruction
DAdd :: Instruction
DALoad :: Instruction
DAStore :: Instruction
DCmpG :: Instruction
DCmpL :: Instruction
DConst0 :: Instruction
DConst1 :: Instruction
DDiv :: Instruction
DLoad :: Instruction
DLoad0 :: Instruction
DLoad1 :: Instruction
DLoad2 :: Instruction
DLoad3 :: Instruction
DMul :: Instruction
DNeg :: Instruction
DRem :: Instruction
DReturn :: Instruction
DStore :: Instruction
DStore0 :: Instruction
DStore1 :: Instruction
DStore2 :: Instruction
DStore3 :: Instruction
DSub :: Instruction
Dup :: Instruction
DupX1 :: Instruction
DupX2 :: Instruction
Dup2 :: Instruction
Dup2X1 :: Instruction
Dup2X2 :: Instruction
F2D :: Instruction
F2I :: Instruction
F2L :: Instruction
FAdd :: Instruction
FALoad :: Instruction
FAStore :: Instruction
FCmpG :: Instruction
FCmpL :: Instruction
FConst0 :: Instruction
FConst1 :: Instruction
FConst2 :: Instruction
FDiv :: Instruction
FLoad :: Instruction
FLoad0 :: Instruction
FLoad1 :: Instruction
FLoad2 :: Instruction
FLoad3 :: Instruction
FMul :: Instruction
FNeg :: Instruction
FRem :: Instruction
FReturn :: Instruction
FStore :: Instruction
FStore0 :: Instruction
FStore1 :: Instruction
FStore2 :: Instruction
FStore3 :: Instruction
FSub :: Instruction
GetField :: ConstantPoolIndex -> Instruction
GetStatic :: ConstantPoolIndex -> Instruction
Goto :: Word16 -> Instruction
GotoW :: Word32 -> Instruction
I2B :: Instruction
I2C :: Instruction
I2D :: Instruction
I2F :: Instruction
I2L :: Instruction
I2S :: Instruction
IAdd :: Instruction
IALoad :: Instruction
IAnd :: Instruction
IAStore :: Instruction
IConstM1 :: Instruction
IConst0 :: Instruction
IConst1 :: Instruction
IConst2 :: Instruction
IConst3 :: Instruction
IConst4 :: Instruction
IConst5 :: Instruction
IDiv :: Instruction

-- | if_acmpeq
IfAcmpEq :: Word16 -> Instruction

-- | if_acmpne Branch if int comparison succeeds
IfAcmpNe :: Word16 -> Instruction
IfIcmpEq :: Word16 -> Instruction
IfIcmpNe :: Word16 -> Instruction
IfIcmpLt :: Word16 -> Instruction
IfIcmpGe :: Word16 -> Instruction
IfIcmpGt :: Word16 -> Instruction
IfIcmpLe :: Word16 -> Instruction
IfEq :: Word16 -> Instruction
IfNe :: Word16 -> Instruction
IfLt :: Word16 -> Instruction
IfGe :: Word16 -> Instruction
IfGt :: Word16 -> Instruction
IfLe :: Word16 -> Instruction
IfNonNull :: Word16 -> Instruction
IfNull :: Word16 -> Instruction
IInc :: Word8 -> Word8 -> Instruction
ILoad :: U1 -> Instruction
ILoad0 :: Instruction
ILoad1 :: Instruction
ILoad2 :: Instruction
ILoad3 :: Instruction
IMul :: Instruction
INeg :: Instruction
Instanceof :: ConstantPoolIndex -> Instruction
InvokeDynamic :: ConstantPoolIndex -> Instruction
InvokeInterface :: ConstantPoolIndex -> Word8 -> Instruction
InvokeSpecial :: ConstantPoolIndex -> Instruction
InvokeStatic :: ConstantPoolIndex -> Instruction
InvokeVirtual :: ConstantPoolIndex -> Instruction
IOr :: Instruction
IRem :: Instruction
IReturn :: Instruction
IShl :: Instruction
IShr :: Instruction
IStore0 :: Instruction
IStore1 :: Instruction
IStore2 :: Instruction
IStore3 :: Instruction
IStore :: U1 -> Instruction
ISub :: Instruction
IUShr :: Instruction
IXor :: Instruction
JSR :: Word16 -> Instruction
JSR_W :: Word32 -> Instruction
L2D :: Instruction
L2F :: Instruction
L2I :: Instruction
LAdd :: Instruction
LALoad :: Instruction
LAnd :: Instruction
LCmp :: Instruction
LConst0 :: Instruction
LConst1 :: Instruction
LDC :: U1 -> Instruction
LDC2_W :: ConstantPoolIndex -> Instruction
LDC_W :: ConstantPoolIndex -> Instruction
LDiv :: Instruction
LLoad :: Instruction
LLoad0 :: Instruction
LLoad1 :: Instruction
LLoad2 :: Instruction
LLoad3 :: Instruction
LMul :: Instruction
LNeg :: Instruction
LookupSwitch :: Word32 -> [(Word32, Word32)] -> Instruction
LOr :: Instruction
LRem :: Instruction
LReturn :: Instruction
LShl :: Instruction
LShr :: Instruction
LStore :: Instruction
LStore0 :: Instruction
LStore1 :: Instruction
LStore2 :: Instruction
LStore3 :: Instruction
LSub :: Instruction
LUShr :: Instruction
LXor :: Instruction
MonitorEnter :: Instruction
MonitorExit :: Instruction
MultiANewArray :: ConstantPoolIndex -> Word8 -> Instruction
New :: ConstantPoolIndex -> Instruction
NewArray :: ArrayType -> Instruction
NOP :: Instruction
Pop :: Instruction
Pop2 :: Instruction
PutField :: ConstantPoolIndex -> Instruction
PutStatic :: ConstantPoolIndex -> Instruction
Ret :: Word8 -> Instruction
Return :: Instruction
SALoad :: Instruction
SAStore :: Instruction
SIPush :: Word16 -> Instruction
Swap :: Instruction
TableSwitch :: Word32 -> Word32 -> Word32 -> [(Word32, Word32)] -> Instruction
Wide :: Word8 -> Word16 -> Instruction
putInstruction :: Instruction -> Put
instance GHC.Classes.Eq JVM.Data.Raw.Instruction.Instruction
instance GHC.Internal.Show.Show JVM.Data.Raw.Instruction.Instruction
instance Data.Binary.Write.WriteBinary JVM.Data.Raw.Instruction.Instruction

module JVM.Data.Raw.ConstantPool
data ConstantPoolInfo

-- | 
--   <a>https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.1</a>
ClassInfo :: U2 -> ConstantPoolInfo
[nameIndex] :: ConstantPoolInfo -> U2
FieldRefInfo :: U2 -> U2 -> ConstantPoolInfo
[classIndex] :: ConstantPoolInfo -> U2
[nameAndTypeIndex] :: ConstantPoolInfo -> U2
MethodRefInfo :: U2 -> U2 -> ConstantPoolInfo
[classIndex] :: ConstantPoolInfo -> U2
[nameAndTypeIndex] :: ConstantPoolInfo -> U2
InterfaceMethodRefInfo :: U2 -> U2 -> ConstantPoolInfo
[classIndex] :: ConstantPoolInfo -> U2
[nameAndTypeIndex] :: ConstantPoolInfo -> U2
StringInfo :: U2 -> ConstantPoolInfo
[stringIndex] :: ConstantPoolInfo -> U2
IntegerInfo :: U4 -> ConstantPoolInfo
[bytes] :: ConstantPoolInfo -> U4
FloatInfo :: U4 -> ConstantPoolInfo
[bytes] :: ConstantPoolInfo -> U4
LongInfo :: U4 -> U4 -> ConstantPoolInfo
[highBytes] :: ConstantPoolInfo -> U4
[lowBytes] :: ConstantPoolInfo -> U4
DoubleInfo :: U4 -> U4 -> ConstantPoolInfo
[highBytes] :: ConstantPoolInfo -> U4
[lowBytes] :: ConstantPoolInfo -> U4
NameAndTypeInfo :: U2 -> U2 -> ConstantPoolInfo
[nameIndex] :: ConstantPoolInfo -> U2
[descriptorIndex] :: ConstantPoolInfo -> U2
UTF8Info :: ByteString -> ConstantPoolInfo
[utfBytes] :: ConstantPoolInfo -> ByteString
MethodHandleInfo :: U1 -> U2 -> ConstantPoolInfo
[referenceKind] :: ConstantPoolInfo -> U1
[referenceIndex] :: ConstantPoolInfo -> U2
MethodTypeInfo :: U2 -> ConstantPoolInfo
[descriptorIndex] :: ConstantPoolInfo -> U2
InvokeDynamicInfo :: U2 -> U2 -> ConstantPoolInfo
[bootstrapMethodAttrIndex] :: ConstantPoolInfo -> U2
[nameAndTypeIndex] :: ConstantPoolInfo -> U2
instance GHC.Classes.Eq JVM.Data.Raw.ConstantPool.ConstantPoolInfo
instance GHC.Classes.Ord JVM.Data.Raw.ConstantPool.ConstantPoolInfo
instance GHC.Internal.Show.Show JVM.Data.Raw.ConstantPool.ConstantPoolInfo
instance Data.Binary.Write.WriteBinary JVM.Data.Raw.ConstantPool.ConstantPoolInfo

module JVM.Data.Raw.ClassFile

-- | Low level representation of the class file format. This is the closest
--   representation to the actual format of the class file, that makes only
--   a few compromises for convenience, such as omitting the explicit
--   x_count fields, instead calculating them from the length of the
--   corresponding vectors. This has the added bonus of making it
--   impossible to construct an invalid class file (in this regard anyway)
data ClassFile
ClassFile :: Word32 -> MinorVersion -> MajorVersion -> Vector ConstantPoolInfo -> Word16 -> Word16 -> Word16 -> Vector Word16 -> Vector FieldInfo -> Vector MethodInfo -> Vector AttributeInfo -> ClassFile
[magic] :: ClassFile -> Word32
[minorVersion] :: ClassFile -> MinorVersion
[majorVersion] :: ClassFile -> MajorVersion
[constantPool] :: ClassFile -> Vector ConstantPoolInfo
[accessFlags] :: ClassFile -> Word16
[thisClass] :: ClassFile -> Word16
[superClass] :: ClassFile -> Word16
[interfaces] :: ClassFile -> Vector Word16
[fields] :: ClassFile -> Vector FieldInfo
[methods] :: ClassFile -> Vector MethodInfo
[attributes] :: ClassFile -> Vector AttributeInfo
data FieldInfo
FieldInfo :: Word16 -> Word16 -> Word16 -> Vector AttributeInfo -> FieldInfo
[accessFlags] :: FieldInfo -> Word16
[nameIndex] :: FieldInfo -> Word16
[descriptorIndex] :: FieldInfo -> Word16
[attributes] :: FieldInfo -> Vector AttributeInfo
data AttributeInfo
AttributeInfo :: Word16 -> Attribute -> AttributeInfo
[nameIndex] :: AttributeInfo -> Word16
[info] :: AttributeInfo -> Attribute
data Attribute
CodeAttribute :: Word16 -> Word16 -> Vector Instruction -> Vector ExceptionTableEntry -> Vector AttributeInfo -> Attribute
[maxStack] :: Attribute -> Word16
[maxLocals] :: Attribute -> Word16
[code] :: Attribute -> Vector Instruction
[exceptionTable] :: Attribute -> Vector ExceptionTableEntry
[codeAttributes] :: Attribute -> Vector AttributeInfo
InnerClassesAttribute :: Vector InnerClassInfo -> Attribute
LineNumberTableAttribute :: Vector LineNumberTableEntry -> Attribute
StackMapTableAttribute :: Vector StackMapFrame -> Attribute
ConstantValueAttribute :: Word16 -> Attribute
SourceFileAttribute :: Word16 -> Attribute
BootstrapMethodsAttribute :: Vector BootstrapMethod -> Attribute
data InnerClassInfo
InnerClassInfo :: Word16 -> Word16 -> Word16 -> Word16 -> InnerClassInfo
[innerClassInfo] :: InnerClassInfo -> Word16
[outerClassInfo] :: InnerClassInfo -> Word16
[innerName] :: InnerClassInfo -> Word16
[accessFlags] :: InnerClassInfo -> Word16
data LineNumberTableEntry
LineNumberTableEntry :: U2 -> U2 -> LineNumberTableEntry
[startPc] :: LineNumberTableEntry -> U2
[lineNumber] :: LineNumberTableEntry -> U2

-- | The stack map frame types are defined as follows: &gt; union
--   stack_map_frame { &gt; same_frame; &gt;
--   same_locals_1_stack_item_frame; &gt;
--   same_locals_1_stack_item_frame_extended; &gt; chop_frame; &gt;
--   same_frame_extended; &gt; append_frame; &gt; full_frame; &gt;}
data StackMapFrame

-- | 0-63
SameFrame :: U1 -> StackMapFrame

-- | <pre>
--    same_locals_1_stack_item_frame {
--       u1 frame_type = SAME_LOCALS_1_STACK_ITEM; /* 64-127 */
--       verification_type_info stack[1];
--   }
--   </pre>
SameLocals1StackItemFrame :: VerificationTypeInfo -> U1 -> StackMapFrame
SameLocals1StackItemFrameExtended :: VerificationTypeInfo -> U2 -> StackMapFrame
SameFrameExtended :: U2 -> StackMapFrame
ChopFrame :: U1 -> U2 -> StackMapFrame
AppendFrame :: Vector VerificationTypeInfo -> U2 -> StackMapFrame
FullFrame :: Vector VerificationTypeInfo -> Vector VerificationTypeInfo -> U2 -> StackMapFrame
data VerificationTypeInfo
TopVariableInfo :: VerificationTypeInfo
IntegerVariableInfo :: VerificationTypeInfo
FloatVariableInfo :: VerificationTypeInfo
LongVariableInfo :: VerificationTypeInfo
DoubleVariableInfo :: VerificationTypeInfo
NullVariableInfo :: VerificationTypeInfo
UninitializedThisVariableInfo :: VerificationTypeInfo
ObjectVariableInfo :: Word16 -> VerificationTypeInfo
UninitializedVariableInfo :: U2 -> VerificationTypeInfo
data BootstrapMethod
BootstrapMethod :: Word16 -> Vector Word16 -> BootstrapMethod
[bootstrapMethodRef] :: BootstrapMethod -> Word16
[bootstrapArguments] :: BootstrapMethod -> Vector Word16
data ExceptionTableEntry
ExceptionTableEntry :: Word16 -> Word16 -> Word16 -> Word16 -> ExceptionTableEntry
[startPc] :: ExceptionTableEntry -> Word16
[endPc] :: ExceptionTableEntry -> Word16
[handlerPc] :: ExceptionTableEntry -> Word16
[catchType] :: ExceptionTableEntry -> Word16
data MethodInfo
MethodInfo :: Word16 -> Word16 -> Word16 -> Vector AttributeInfo -> MethodInfo
[accessFlags] :: MethodInfo -> Word16
[nameIndex] :: MethodInfo -> Word16
[descriptorIndex] :: MethodInfo -> Word16
[attributes] :: MethodInfo -> Vector AttributeInfo
putConstantPool :: Vector ConstantPoolInfo -> Put
putInterfaceTable :: Vector Word16 -> Put
putFieldTable :: Vector FieldInfo -> Put
putAttributes :: Vector AttributeInfo -> Put

-- | Puts the attribute data. This must not include length or name, just
--   the actual value
putAttribute :: Attribute -> Put
putBootstrapMethod :: BootstrapMethod -> Put
putExceptionTable :: Vector ExceptionTableEntry -> Put
putMethodTable :: Vector MethodInfo -> Put
instance GHC.Classes.Eq JVM.Data.Raw.ClassFile.BootstrapMethod
instance GHC.Classes.Ord JVM.Data.Raw.ClassFile.BootstrapMethod
instance GHC.Internal.Show.Show JVM.Data.Raw.ClassFile.Attribute
instance GHC.Internal.Show.Show JVM.Data.Raw.ClassFile.AttributeInfo
instance GHC.Internal.Show.Show JVM.Data.Raw.ClassFile.BootstrapMethod
instance GHC.Internal.Show.Show JVM.Data.Raw.ClassFile.ClassFile
instance GHC.Internal.Show.Show JVM.Data.Raw.ClassFile.ExceptionTableEntry
instance GHC.Internal.Show.Show JVM.Data.Raw.ClassFile.FieldInfo
instance GHC.Internal.Show.Show JVM.Data.Raw.ClassFile.InnerClassInfo
instance GHC.Internal.Show.Show JVM.Data.Raw.ClassFile.LineNumberTableEntry
instance GHC.Internal.Show.Show JVM.Data.Raw.ClassFile.MethodInfo
instance GHC.Internal.Show.Show JVM.Data.Raw.ClassFile.StackMapFrame
instance GHC.Internal.Show.Show JVM.Data.Raw.ClassFile.VerificationTypeInfo
instance Data.Binary.Write.WriteBinary JVM.Data.Raw.ClassFile.AttributeInfo
instance Data.Binary.Write.WriteBinary JVM.Data.Raw.ClassFile.ClassFile
instance Data.Binary.Write.WriteBinary JVM.Data.Raw.ClassFile.ExceptionTableEntry
instance Data.Binary.Write.WriteBinary JVM.Data.Raw.ClassFile.FieldInfo
instance Data.Binary.Write.WriteBinary JVM.Data.Raw.ClassFile.MethodInfo

module JVM.Data.Convert.Numbers

-- | Converts a Haskell float to the JVM representation
toJVMFloat :: Float -> U4
toJVMLong :: Int64 -> (U4, U4)
toJVMDouble :: Double -> (U4, U4)

module JVM.Data.Convert.ConstantPool
data ConstantPoolState
ConstantPoolState :: IndexedMap ConstantPoolInfo -> IndexedMap BootstrapMethod -> ConstantPoolState
[constantPool] :: ConstantPoolState -> IndexedMap ConstantPoolInfo
[bootstrapMethods] :: ConstantPoolState -> IndexedMap BootstrapMethod

-- | Effect for managing the constant pool state
data ConstantPool (m :: k) a
[GetCP] :: forall {k} (m :: k). ConstantPool m ConstantPoolState
[SetCP] :: forall {k} (m :: k). ConstantPoolState -> ConstantPool m ()

-- | Perform the operation <a>GetCP</a>.
getCP :: forall {k} (es :: [Effect]). (HasCallStack, (ConstantPool :: (Type -> Type) -> Type -> Type) :> es) => Eff es ConstantPoolState

-- | Perform the operation <a>SetCP</a>.
setCP :: forall {k} (es :: [Effect]). (HasCallStack, (ConstantPool :: (Type -> Type) -> Type -> Type) :> es) => ConstantPoolState -> Eff es ()
lookupOrInsertMOver :: forall (r :: [Effect]) a. ((ConstantPool :: (Type -> Type) -> Type -> Type) :> r, Ord a) => a -> (ConstantPoolState -> IndexedMap a) -> (ConstantPoolState -> IndexedMap a -> ConstantPoolState) -> Eff r Int
lookupOrInsertMCP :: forall (r :: [Effect]). (ConstantPool :: (Type -> Type) -> Type -> Type) :> r => ConstantPoolInfo -> Eff r Int
lookupOrInsertMBM :: forall (r :: [Effect]). (ConstantPool :: (Type -> Type) -> Type -> Type) :> r => BootstrapMethod -> Eff r Int
transformEntry :: forall (r :: [Effect]). (ConstantPool :: (Type -> Type) -> Type -> Type) :> r => ConstantPoolEntry -> Eff r Int
convertBootstrapMethod :: forall (r :: [Effect]). (ConstantPool :: (Type -> Type) -> Type -> Type) :> r => BootstrapMethod -> Eff r Int
findIndexOf :: forall (r :: [Effect]). (ConstantPool :: (Type -> Type) -> Type -> Type) :> r => ConstantPoolEntry -> Eff r U2
constantPoolToState :: forall (r :: [Effect]) a. State ConstantPoolState :> r => Eff ((ConstantPool :: (Type -> Type) -> Type -> Type) ': r) a -> Eff r a
runConstantPoolWith :: forall (r :: [(Type -> Type) -> Type -> Type]) a. ConstantPoolState -> Eff ((ConstantPool :: (Type -> Type) -> Type -> Type) ': r) a -> Eff r (a, ConstantPoolState)
runConstantPool :: forall (r :: [(Type -> Type) -> Type -> Type]) a. Eff ((ConstantPool :: (Type -> Type) -> Type -> Type) ': r) a -> Eff r (a, ConstantPoolState)
instance GHC.Classes.Eq JVM.Data.Convert.ConstantPool.ConstantPoolState
instance GHC.Internal.Base.Monoid JVM.Data.Convert.ConstantPool.ConstantPoolState
instance GHC.Classes.Ord JVM.Data.Convert.ConstantPool.ConstantPoolState
instance GHC.Internal.Base.Semigroup JVM.Data.Convert.ConstantPool.ConstantPoolState
instance GHC.Internal.Show.Show JVM.Data.Convert.ConstantPool.ConstantPoolState

module JVM.Data.Convert.Monad
type ConvertEff (r :: [Effect]) = (ConstantPool :: Type -> Type -> Type -> Type :> r, Error CodeConverterError :> r)
runConvertM :: forall (r :: [(Type -> Type) -> Type -> Type]) a. Eff ((ConstantPool :: (Type -> Type) -> Type -> Type) ': (Error CodeConverterError ': r)) a -> Eff r (Either CodeConverterError (a, ConstantPoolState))
data CodeConverterError
DuplicateLabel :: Label -> Word16 -> CodeConverterError
UnmarkedLabel :: Label -> CodeConverterError
instance GHC.Internal.Show.Show JVM.Data.Convert.Monad.CodeConverterError


-- | High level representation of a JVM instruction, with type-safe
--   arguments and no stack manipulation needed. This is not a 1-1 mapping
--   to the actual instructions, use <a>Instruction</a> for that. Instead,
--   this includes some conveniences like the <a>Label</a> instruction to
--   avoid manually dealing with jump offsets.
module JVM.Data.Abstract.Instruction
type Reference = Int
type Instruction = Instruction' Label
data Instruction' label
ALoad :: U1 -> Instruction' label
AStore :: U1 -> Instruction' label
AReturn :: Instruction' label
AConstNull :: Instruction' label
Dup :: Instruction' label
IfEq :: label -> Instruction' label
IfNe :: label -> Instruction' label
IfLt :: label -> Instruction' label
IfGe :: label -> Instruction' label
IfGt :: label -> Instruction' label
IfLe :: label -> Instruction' label
Instanceof :: ClassInfoType -> Instruction' label
InvokeStatic :: ClassInfoType -> Text -> MethodDescriptor -> Instruction' label
InvokeInterface :: ClassInfoType -> Text -> MethodDescriptor -> Instruction' label
InvokeVirtual :: ClassInfoType -> Text -> MethodDescriptor -> Instruction' label
InvokeDynamic :: BootstrapMethod -> Text -> MethodDescriptor -> Instruction' label
InvokeSpecial :: ClassInfoType -> Text -> MethodDescriptor -> Instruction' label
ILoad :: U1 -> Instruction' label
IStore :: U1 -> Instruction' label
Label :: label -> Instruction' label
LDC :: LDCEntry -> Instruction' label
PutStatic :: ClassInfoType -> Text -> FieldType -> Instruction' label
GetField :: ClassInfoType -> Text -> FieldType -> Instruction' label
GetStatic :: ClassInfoType -> Text -> FieldType -> Instruction' label
PutField :: ClassInfoType -> Text -> FieldType -> Instruction' label
Goto :: label -> Instruction' label
CheckCast :: ClassInfoType -> Instruction' label
Return :: Instruction' label
New :: ClassInfoType -> Instruction' label
jumpTarget :: Instruction' label -> Maybe label
data LDCEntry
LDCInt :: Int -> LDCEntry
LDCFloat :: Float -> LDCEntry
LDCString :: Text -> LDCEntry
LDCClass :: ClassInfoType -> LDCEntry
ldcEntryToFieldType :: LDCEntry -> FieldType
instance GHC.Internal.Data.Data.Data label => GHC.Internal.Data.Data.Data (JVM.Data.Abstract.Instruction.Instruction' label)
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.Instruction.LDCEntry
instance GHC.Classes.Eq label => GHC.Classes.Eq (JVM.Data.Abstract.Instruction.Instruction' label)
instance GHC.Classes.Eq JVM.Data.Abstract.Instruction.LDCEntry
instance GHC.Internal.Base.Functor JVM.Data.Abstract.Instruction.Instruction'
instance GHC.Internal.Generics.Generic (JVM.Data.Abstract.Instruction.Instruction' label)
instance GHC.Internal.Generics.Generic JVM.Data.Abstract.Instruction.LDCEntry
instance GHC.Classes.Ord label => GHC.Classes.Ord (JVM.Data.Abstract.Instruction.Instruction' label)
instance GHC.Classes.Ord JVM.Data.Abstract.Instruction.LDCEntry
instance Prettyprinter.Internal.Pretty label => Prettyprinter.Internal.Pretty (JVM.Data.Abstract.Instruction.Instruction' label)
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.Instruction.LDCEntry
instance GHC.Internal.Show.Show label => GHC.Internal.Show.Show (JVM.Data.Abstract.Instruction.Instruction' label)
instance GHC.Internal.Show.Show JVM.Data.Abstract.Instruction.LDCEntry


-- | Converts abstract instructions into raw instructions This includes
--   resolving labels into offsets TODO: this is very inefficient,
--   requiring three passes over the instructions
module JVM.Data.Convert.Instruction
type CodeConverterEff (r :: [Effect]) = (ConstantPool :: Type -> Type -> Type -> Type :> r, State ConvertState :> r, Error CodeConverterError :> r)
fullyRunCodeConverter :: forall (r' :: [Effect]) a. ConvertEff r' => Eff (State ConvertState ': r') a -> Eff r' a
convertInstructions :: forall (r :: [Effect]). CodeConverterEff r => [Instruction] -> Eff r [Instruction]
fullyResolveAbs :: forall (r :: [Effect]). CodeConverterEff r => Label -> Eff r Word16
instance GHC.Classes.Eq a => GHC.Classes.Eq (JVM.Data.Convert.Instruction.OffsetInstruction a)
instance GHC.Internal.Base.Functor JVM.Data.Convert.Instruction.OffsetInstruction
instance GHC.Classes.Ord a => GHC.Classes.Ord (JVM.Data.Convert.Instruction.OffsetInstruction a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (JVM.Data.Convert.Instruction.OffsetInstruction a)

module JVM.Data.Abstract.ClassFile.Method
data ClassFileMethod
ClassFileMethod :: [MethodAccessFlag] -> Text -> MethodDescriptor -> TypeMergingList MethodAttribute -> ClassFileMethod
[methodAccessFlags] :: ClassFileMethod -> [MethodAccessFlag]
[methodName] :: ClassFileMethod -> Text
[methodDescriptor] :: ClassFileMethod -> MethodDescriptor
[methodAttributes] :: ClassFileMethod -> TypeMergingList MethodAttribute
data MethodAttribute
Code :: !CodeAttributeData -> MethodAttribute
data CodeAttributeData
CodeAttributeData :: U2 -> U2 -> [Instruction] -> [ExceptionTableEntry] -> [CodeAttribute] -> CodeAttributeData
[maxStack] :: CodeAttributeData -> U2
[maxLocals] :: CodeAttributeData -> U2
[code] :: CodeAttributeData -> [Instruction]
[exceptionTable] :: CodeAttributeData -> [ExceptionTableEntry]
[codeAttributes] :: CodeAttributeData -> [CodeAttribute]
data ExceptionTableEntry
ExceptionTableEntry :: Int -> Int -> Int -> Maybe ClassInfoType -> ExceptionTableEntry
[startPc] :: ExceptionTableEntry -> Int
[endPc] :: ExceptionTableEntry -> Int
[handlerPc] :: ExceptionTableEntry -> Int
[catchType] :: ExceptionTableEntry -> Maybe ClassInfoType
data CodeAttribute
LineNumberTable :: [LineNumberTableEntry] -> CodeAttribute
StackMapTable :: [StackMapFrame] -> CodeAttribute
data StackMapFrame
SameFrame :: Label -> StackMapFrame
ChopFrame :: !U1 -> !Label -> StackMapFrame
SameLocals1StackItemFrame :: !VerificationTypeInfo -> Label -> StackMapFrame
AppendFrame :: ![VerificationTypeInfo] -> !Label -> StackMapFrame
FullFrame :: ![VerificationTypeInfo] -> ![VerificationTypeInfo] -> !Label -> StackMapFrame
data VerificationTypeInfo
TopVariableInfo :: VerificationTypeInfo
IntegerVariableInfo :: VerificationTypeInfo
FloatVariableInfo :: VerificationTypeInfo
LongVariableInfo :: VerificationTypeInfo
DoubleVariableInfo :: VerificationTypeInfo
NullVariableInfo :: VerificationTypeInfo
UninitializedThisVariableInfo :: VerificationTypeInfo
ObjectVariableInfo :: !ClassInfoType -> VerificationTypeInfo
UninitializedVariableInfo :: !Label -> VerificationTypeInfo
data LineNumberTableEntry
LineNumberTableEntry :: U2 -> U2 -> LineNumberTableEntry
[lineNumberTableEntryStartPc] :: LineNumberTableEntry -> U2
[lineNumberTableEntryLineNumber] :: LineNumberTableEntry -> U2
instance Data.TypeMergingList.DataMergeable JVM.Data.Abstract.ClassFile.Method.CodeAttribute
instance Data.TypeMergingList.DataMergeable JVM.Data.Abstract.ClassFile.Method.CodeAttributeData
instance Data.TypeMergingList.DataMergeable JVM.Data.Abstract.ClassFile.Method.MethodAttribute
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.ClassFile.Method.CodeAttribute
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.ClassFile.Method.CodeAttributeData
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.ClassFile.Method.ExceptionTableEntry
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.ClassFile.Method.LineNumberTableEntry
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.ClassFile.Method.MethodAttribute
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.ClassFile.Method.StackMapFrame
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.ClassFile.Method.VerificationTypeInfo
instance GHC.Classes.Eq JVM.Data.Abstract.ClassFile.Method.CodeAttribute
instance GHC.Classes.Eq JVM.Data.Abstract.ClassFile.Method.LineNumberTableEntry
instance GHC.Classes.Eq JVM.Data.Abstract.ClassFile.Method.StackMapFrame
instance GHC.Classes.Eq JVM.Data.Abstract.ClassFile.Method.VerificationTypeInfo
instance GHC.Internal.Generics.Generic JVM.Data.Abstract.ClassFile.Method.CodeAttribute
instance GHC.Internal.Generics.Generic JVM.Data.Abstract.ClassFile.Method.CodeAttributeData
instance GHC.Internal.Generics.Generic JVM.Data.Abstract.ClassFile.Method.ExceptionTableEntry
instance GHC.Internal.Generics.Generic JVM.Data.Abstract.ClassFile.Method.MethodAttribute
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ClassFile.Method.ClassFileMethod
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ClassFile.Method.CodeAttribute
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ClassFile.Method.CodeAttributeData
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ClassFile.Method.ExceptionTableEntry
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ClassFile.Method.LineNumberTableEntry
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ClassFile.Method.MethodAttribute
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ClassFile.Method.StackMapFrame
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ClassFile.Method.VerificationTypeInfo
instance GHC.Internal.Show.Show JVM.Data.Abstract.ClassFile.Method.ClassFileMethod
instance GHC.Internal.Show.Show JVM.Data.Abstract.ClassFile.Method.CodeAttribute
instance GHC.Internal.Show.Show JVM.Data.Abstract.ClassFile.Method.CodeAttributeData
instance GHC.Internal.Show.Show JVM.Data.Abstract.ClassFile.Method.ExceptionTableEntry
instance GHC.Internal.Show.Show JVM.Data.Abstract.ClassFile.Method.LineNumberTableEntry
instance GHC.Internal.Show.Show JVM.Data.Abstract.ClassFile.Method.MethodAttribute
instance GHC.Internal.Show.Show JVM.Data.Abstract.ClassFile.Method.StackMapFrame
instance GHC.Internal.Show.Show JVM.Data.Abstract.ClassFile.Method.VerificationTypeInfo

module JVM.Data.Convert.Method
foldMWith :: Monad m => (a -> b -> m (a, c)) -> a -> [b] -> m (a, [c])
convertMethodAttribute :: forall (r :: [Effect]). (ConvertEff r, HasCallStack) => MethodAttribute -> Eff r AttributeInfo
convertVerificationTypeInfo :: forall (r :: [Effect]). CodeConverterEff r => VerificationTypeInfo -> Eff r VerificationTypeInfo
convertMethod :: forall (r :: [Effect]). ConvertEff r => ClassFileMethod -> Eff r MethodInfo


-- | Generate a stack map table for a method. This process MUST run last in
--   the high level stage - modifications to the code after this point will
--   invalidate the stack map table and cause invalid class files to be
--   generated.
module JVM.Data.Analyse.StackMap
data BasicBlock
BasicBlock :: Int -> [Instruction] -> Maybe Label -> BasicBlock
[index] :: BasicBlock -> Int
[instructions] :: BasicBlock -> [Instruction]
[end] :: BasicBlock -> Maybe Label
data Frame
Frame :: [LocalVariable] -> [StackEntry] -> Frame
[locals] :: Frame -> [LocalVariable]
[stack] :: Frame -> [StackEntry]
data LocalVariable
Uninitialised :: LocalVariable
LocalVariable :: FieldType -> LocalVariable
data StackEntry
StackEntry :: FieldType -> StackEntry
StackEntryTop :: StackEntry
StackEntryNull :: StackEntry
lvToStackEntry :: LocalVariable -> StackEntry
stackEntryToLV :: StackEntry -> LocalVariable
splitIntoBasicBlocks :: [Instruction] -> [BasicBlock]
splitOnLabels :: [Instruction] -> [(Maybe Label, [Instruction])]
topFrame :: MethodDescriptor -> Frame
analyseBlockDiff :: Frame -> BasicBlock -> Frame
frameDiffToSMF :: HasCallStack => Frame -> BasicBlock -> StackMapFrame
lvToVerificationTypeInfo :: LocalVariable -> VerificationTypeInfo
seToVerificationTypeInfo :: StackEntry -> VerificationTypeInfo
calculateStackMapFrames :: MethodDescriptor -> [Instruction] -> [StackMapFrame]
replaceAtOrGrow :: Int -> LocalVariable -> [LocalVariable] -> [LocalVariable]
replaceAt :: Int -> a -> [a] -> [a]
takeWhileInclusive :: (a -> Bool) -> [a] -> [a]
instance GHC.Classes.Eq JVM.Data.Analyse.StackMap.BasicBlock
instance GHC.Classes.Eq JVM.Data.Analyse.StackMap.Frame
instance GHC.Classes.Eq JVM.Data.Analyse.StackMap.LocalVariable
instance GHC.Classes.Eq JVM.Data.Analyse.StackMap.StackEntry
instance GHC.Internal.Show.Show JVM.Data.Analyse.StackMap.BasicBlock
instance GHC.Internal.Show.Show JVM.Data.Analyse.StackMap.Frame
instance GHC.Internal.Show.Show JVM.Data.Analyse.StackMap.LocalVariable
instance GHC.Internal.Show.Show JVM.Data.Analyse.StackMap.StackEntry

module JVM.Data.Abstract.Builder.Code
data CodeBuilder (m :: k) a
[AddCodeAttribute] :: forall {k} (m :: k). CodeAttribute -> CodeBuilder m ()
[NewLabel] :: forall {k} (m :: k). CodeBuilder m Label
[Emit'] :: forall {k} (m :: k). [Instruction] -> CodeBuilder m ()
[GetCode] :: forall {k} (m :: k). CodeBuilder m [Instruction]

-- | Perform the operation <a>AddCodeAttribute</a>.
addCodeAttribute :: forall {k} (es :: [Effect]). (HasCallStack, (CodeBuilder :: (Type -> Type) -> Type -> Type) :> es) => CodeAttribute -> Eff es ()

-- | Perform the operation <a>Emit'</a>.
emit' :: forall {k} (es :: [Effect]). (HasCallStack, (CodeBuilder :: (Type -> Type) -> Type -> Type) :> es) => [Instruction] -> Eff es ()

-- | Perform the operation <a>GetCode</a>.
getCode :: forall {k} (es :: [Effect]). (HasCallStack, (CodeBuilder :: (Type -> Type) -> Type -> Type) :> es) => Eff es [Instruction]

-- | Perform the operation <a>NewLabel</a>.
newLabel :: forall {k} (es :: [Effect]). (HasCallStack, (CodeBuilder :: (Type -> Type) -> Type -> Type) :> es) => Eff es Label
data CodeState
CodeState :: [Label] -> TypeMergingList CodeAttribute -> [Instruction] -> CodeState
[labelSource] :: CodeState -> [Label]
[attributes] :: CodeState -> TypeMergingList CodeAttribute
[code] :: CodeState -> [Instruction]
initialCodeState :: CodeState
emit :: forall (r :: [Effect]). (CodeBuilder :: (Type -> Type) -> Type -> Type) :> r => Instruction -> Eff r ()
codeBuilderToState :: forall (r :: [Effect]) a. State CodeState :> r => Eff ((CodeBuilder :: (Type -> Type) -> Type -> Type) ': r) a -> Eff r a
runCodeBuilder :: forall (r :: [(Type -> Type) -> Type -> Type]) a. Eff ((CodeBuilder :: (Type -> Type) -> Type -> Type) ': r) a -> Eff r (a, [CodeAttribute], [Instruction])

module JVM.Data.Abstract.ClassFile.Field
data ClassFileField
ClassFileField :: [FieldAccessFlag] -> Text -> FieldType -> [FieldAttribute] -> ClassFileField
[fieldAccessFlags] :: ClassFileField -> [FieldAccessFlag]
[fieldName] :: ClassFileField -> Text
[fieldType] :: ClassFileField -> FieldType
[fieldAttributes] :: ClassFileField -> [FieldAttribute]
data FieldAttribute
ConstantValue :: ConstantValue -> FieldAttribute
Synthetic :: FieldAttribute
data ConstantValue
ConstantLong :: JVMLong -> ConstantValue
ConstantFloat :: JVMFloat -> ConstantValue
ConstantDouble :: JVMDouble -> ConstantValue
ConstantInteger :: JVMInt -> ConstantValue
ConstantString :: JVMString -> ConstantValue
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ClassFile.Field.ClassFileField
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ClassFile.Field.ConstantValue
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ClassFile.Field.FieldAttribute
instance GHC.Internal.Show.Show JVM.Data.Abstract.ClassFile.Field.ClassFileField
instance GHC.Internal.Show.Show JVM.Data.Abstract.ClassFile.Field.ConstantValue
instance GHC.Internal.Show.Show JVM.Data.Abstract.ClassFile.Field.FieldAttribute

module JVM.Data.Convert.Field
convertConstantValue :: forall (r :: [Effect]). ConvertEff r => ConstantValue -> Eff r Word16
convertFieldAttribute :: forall (r :: [Effect]). ConvertEff r => FieldAttribute -> Eff r AttributeInfo
convertField :: forall (r :: [Effect]). ConvertEff r => ClassFileField -> Eff r FieldInfo


-- | High level representation of a class file
module JVM.Data.Abstract.ClassFile
data ClassFile
ClassFile :: QualifiedClassName -> JVMVersion -> [ClassAccessFlag] -> Maybe QualifiedClassName -> [QualifiedClassName] -> [ClassFileField] -> [ClassFileMethod] -> TypeMergingList ClassFileAttribute -> ClassFile
[name] :: ClassFile -> QualifiedClassName
[version] :: ClassFile -> JVMVersion
[accessFlags] :: ClassFile -> [ClassAccessFlag]
[superClass] :: ClassFile -> Maybe QualifiedClassName
[interfaces] :: ClassFile -> [QualifiedClassName]
[fields] :: ClassFile -> [ClassFileField]
[methods] :: ClassFile -> [ClassFileMethod]
[attributes] :: ClassFile -> TypeMergingList ClassFileAttribute
data ClassFileAttribute
InnerClasses :: [InnerClassInfo] -> ClassFileAttribute
EnclosingMethod :: ClassFileAttribute
Synthetic :: ClassFileAttribute
Signature :: ClassFileAttribute
SourceFile :: Text -> ClassFileAttribute
SourceDebugExtension :: ClassFileAttribute
Deprecated :: ClassFileAttribute
RuntimeVisibleAnnotations :: ClassFileAttribute
RuntimeInvisibleAnnotations :: ClassFileAttribute
BootstrapMethods :: [BootstrapMethod] -> ClassFileAttribute
data InnerClassInfo
InnerClassInfo :: QualifiedClassName -> QualifiedClassName -> Text -> [ClassAccessFlag] -> InnerClassInfo
[innerClassInfo] :: InnerClassInfo -> QualifiedClassName
[outerClassInfo] :: InnerClassInfo -> QualifiedClassName
[innerName] :: InnerClassInfo -> Text
[accessFlags] :: InnerClassInfo -> [ClassAccessFlag]
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.ClassFile.ClassFileAttribute
instance GHC.Internal.Data.Data.Data JVM.Data.Abstract.ClassFile.InnerClassInfo
instance Data.TypeMergingList.DataMergeable JVM.Data.Abstract.ClassFile.ClassFileAttribute
instance GHC.Classes.Eq JVM.Data.Abstract.ClassFile.ClassFileAttribute
instance GHC.Classes.Eq JVM.Data.Abstract.ClassFile.InnerClassInfo
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ClassFile.ClassFile
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ClassFile.ClassFileAttribute
instance Prettyprinter.Internal.Pretty JVM.Data.Abstract.ClassFile.InnerClassInfo
instance GHC.Internal.Show.Show JVM.Data.Abstract.ClassFile.ClassFile
instance GHC.Internal.Show.Show JVM.Data.Abstract.ClassFile.ClassFileAttribute
instance GHC.Internal.Show.Show JVM.Data.Abstract.ClassFile.InnerClassInfo


-- | Converts between high level and low level representations
module JVM.Data.Convert
jloName :: QualifiedClassName
convertClassAttributes :: forall (r :: [Effect]). ConvertEff r => [ClassFileAttribute] -> Eff r [AttributeInfo]
convert :: ClassFile -> Either CodeConverterError ClassFile


-- | Provides a monadic interface for building class files in a high-level
--   format.
module JVM.Data.Abstract.Builder
data ClassBuilder (m :: k) a
[ModifyClass] :: forall {k} (m :: k). (ClassFile -> ClassFile) -> ClassBuilder m ()
[GetClass] :: forall {k} (m :: k). ClassBuilder m ClassFile

-- | Perform the operation <a>GetClass</a>.
getClass :: forall {k} (es :: [Effect]). (HasCallStack, (ClassBuilder :: (Type -> Type) -> Type -> Type) :> es) => Eff es ClassFile

-- | Perform the operation <a>ModifyClass</a>.
modifyClass :: forall {k} (es :: [Effect]). (HasCallStack, (ClassBuilder :: (Type -> Type) -> Type -> Type) :> es) => (ClassFile -> ClassFile) -> Eff es ()
addAccessFlag :: forall (r :: [Effect]). (ClassBuilder :: (Type -> Type) -> Type -> Type) :> r => ClassAccessFlag -> Eff r ()
setName :: forall (r :: [Effect]). (ClassBuilder :: (Type -> Type) -> Type -> Type) :> r => QualifiedClassName -> Eff r ()
getName :: forall (r :: [Effect]). (ClassBuilder :: (Type -> Type) -> Type -> Type) :> r => Eff r QualifiedClassName
setVersion :: forall (r :: [Effect]). (ClassBuilder :: (Type -> Type) -> Type -> Type) :> r => JVMVersion -> Eff r ()
setSuperClass :: forall (r :: [Effect]). (ClassBuilder :: (Type -> Type) -> Type -> Type) :> r => QualifiedClassName -> Eff r ()
addInterface :: forall (r :: [Effect]). (ClassBuilder :: (Type -> Type) -> Type -> Type) :> r => QualifiedClassName -> Eff r ()
addField :: forall (r :: [Effect]). (ClassBuilder :: (Type -> Type) -> Type -> Type) :> r => ClassFileField -> Eff r ()
addMethod :: forall (r :: [Effect]). (ClassBuilder :: (Type -> Type) -> Type -> Type) :> r => ClassFileMethod -> Eff r ()
addAttribute :: forall (r :: [Effect]). (ClassBuilder :: (Type -> Type) -> Type -> Type) :> r => ClassFileAttribute -> Eff r ()
addBootstrapMethod :: forall (r :: [Effect]). (ClassBuilder :: (Type -> Type) -> Type -> Type) :> r => BootstrapMethod -> Eff r ()
dummyClass :: QualifiedClassName -> JVMVersion -> ClassFile
classBuilderToState :: forall (r :: [Effect]) a. State ClassFile :> r => Eff ((ClassBuilder :: (Type -> Type) -> Type -> Type) ': r) a -> Eff r a
runClassBuilder :: forall (r :: [(Type -> Type) -> Type -> Type]) a. QualifiedClassName -> JVMVersion -> Eff ((ClassBuilder :: (Type -> Type) -> Type -> Type) ': r) a -> Eff r (ClassFile, a)
